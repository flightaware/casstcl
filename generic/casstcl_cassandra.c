/*
 * casstcl_cassandra - Functions used to talk to Cassandra through the cpp driver
 * 						eg. upsert, select, delete, list keyspace, columns, and tables
 *
 * casstcl - Tcl interface to CassDB
 *
 * Copyright (C) 2014 FlightAware LLC
 *
 * freely redistributable under the Berkeley license
 */

#include "casstcl.h"
#include "casstcl_log.h"
#include "casstcl_prepared.h"
#include "casstcl_batch.h"
#include "casstcl_cassandra.h"
#include "casstcl_types.h"
#include "casstcl_error.h"
#include "casstcl_consistency.h"
#include "casstcl_event.h"
#include "casstcl_future.h"

#include <assert.h>

// Function Declarations
int casstcl_cassObjectObjCmd(ClientData cData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]);
int casstcl_reimport_column_type_map (casstcl_sessionClientData *ct);
int casstcl_list_columns (casstcl_sessionClientData *ct, char *keyspace, char *table, 
	int includeTypes, Tcl_Obj **objPtr);
int casstcl_list_tables (casstcl_sessionClientData *ct, char *keyspace, Tcl_Obj **objPtr);
int casstcl_list_keyspaces (casstcl_sessionClientData *ct, Tcl_Obj **objPtr);

// possibly unfortunately, the cassandra cpp-driver logging stuff is global
Tcl_Obj *casstcl_loggingCallbackObj = NULL;
Tcl_ThreadId casstcl_loggingCallbackThreadId = NULL;

/*
 *--------------------------------------------------------------
 *
 * casstcl_cassObjectDelete -- command deletion callback routine.
 *
 * Results:
 *      ...destroys the cass connection handle.
 *      ...frees memory.
 *
 * Side effects:
 *      None.
 *
 *--------------------------------------------------------------
 */
void
casstcl_cassObjectDelete (ClientData clientData)
{
    casstcl_sessionClientData *ct = (casstcl_sessionClientData *)clientData;

    assert (ct->cass_session_magic == CASS_SESSION_MAGIC);

	cass_ssl_free (ct->ssl);
    cass_cluster_free (ct->cluster);
    cass_session_free (ct->session);

    ckfree((char *)clientData);
}


/*
 *--------------------------------------------------------------
 *
 * casstcl_invoke_callback_with_argument --
 *
 *     The twist here is that a callback object might be a list, not
 *     just a command name, like the argument to -callback might be
 *     more than just a function name, like it could be an object name
 *     and a method name and an argument or whatever.
 *
 *     This code splits out that list and generates up an eval thingie
 *     and invokes it with the additional argument tacked onto the end,
 *     a future object or the like.
 *
 * Results:
 *
 * Side effects:
 *      None.
 *
 *--------------------------------------------------------------
 */
int
casstcl_invoke_callback_with_argument (Tcl_Interp *interp, Tcl_Obj *callbackObj, Tcl_Obj *argumentObj) {
	int callbackListObjc;
	Tcl_Obj **callbackListObjv;
	int tclReturnCode;

	int evalObjc;
	Tcl_Obj **evalObjv;

	int i;

	if (Tcl_ListObjGetElements (interp, callbackObj, &callbackListObjc, &callbackListObjv) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while converting callback argument", NULL);
		return TCL_ERROR;
	}

	evalObjc = callbackListObjc + 1;
	evalObjv = (Tcl_Obj **)ckalloc (sizeof (Tcl_Obj *) * evalObjc);

	for (i = 0; i < callbackListObjc; i++) {
		evalObjv[i] = callbackListObjv[i];
		Tcl_IncrRefCount (evalObjv[i]);
	}

	evalObjv[evalObjc - 1] = argumentObj;
	Tcl_IncrRefCount (evalObjv[evalObjc - 1]);

	tclReturnCode = Tcl_EvalObjv (interp, evalObjc, evalObjv, (TCL_EVAL_GLOBAL|TCL_EVAL_DIRECT));

	// if we got a Tcl error, since we initiated the event, it doesn't
	// have anything to traceback further from here to, we must initiate
	// a background error, which will generally cause the bgerror proc
	// to get invoked
	if (tclReturnCode == TCL_ERROR) {
		Tcl_BackgroundError (interp);
	}

	for (i = 0; i < evalObjc; i++) {
		Tcl_DecrRefCount (evalObjv[i]);
	}

	ckfree ((char *)evalObjv);
	return tclReturnCode;
}

/*
 *----------------------------------------------------------------------
 *
 * casstcl_cassObjCmd --
 *
 *      Create a cass object...
 *
 *      cass create my_cass
 *      cass create #auto
 *
 * The created object is invoked to do things with a CassDB
 *
 * Results:
 *      A standard Tcl result.
 *
 *
 *----------------------------------------------------------------------
 */

    /* ARGSUSED */
int
casstcl_cassObjCmd(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    casstcl_sessionClientData *ct;
    int                 optIndex;
    char               *commandName;
    int                 autoGeneratedName;

    static CONST char *options[] = {
        "create",
        "logging_callback",
        "log_level",
        NULL
    };

    enum options {
        OPT_CREATE,
		OPT_LOGGING_CALLBACK,
		OPT_LOG_LEVEL
    };

    // basic command line processing
    if (objc < 2) {
        Tcl_WrongNumArgs (interp, 1, objv, "subcommand ?args?");
        return TCL_ERROR;
    }

    // argument must be one of the subOptions defined above
    if (Tcl_GetIndexFromObj (interp, objv[1], options, "option",
        TCL_EXACT, &optIndex) != TCL_OK) {
        return TCL_ERROR;
    }

    switch ((enum options) optIndex) {
		case OPT_CREATE: {
			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 1, objv, "option arg");
				return TCL_ERROR;
			}

			// allocate one of our cass client data objects for Tcl and configure it
			ct = (casstcl_sessionClientData *)ckalloc (sizeof (casstcl_sessionClientData));

			ct->cass_session_magic = CASS_SESSION_MAGIC;
			ct->interp = interp;
			ct->session = cass_session_new ();
			ct->cluster = cass_cluster_new ();
			ct->ssl = cass_ssl_new ();

			ct->threadId = Tcl_GetCurrentThread();

			Tcl_CreateEventSource (casstcl_EventSetupProc, casstcl_EventCheckProc, NULL);

			commandName = Tcl_GetString (objv[2]);

			// if commandName is #auto, generate a unique name for the object
			autoGeneratedName = 0;
			if (strcmp (commandName, "#auto") == 0) {
				static unsigned long nextAutoCounter = 0;
				char *objName;
				int    baseNameLength;

				objName = Tcl_GetStringFromObj (objv[0], &baseNameLength);
				baseNameLength += snprintf (NULL, 0, "%lu", nextAutoCounter) + 1;
				commandName = ckalloc (baseNameLength);
				snprintf (commandName, baseNameLength, "%s%lu", objName, nextAutoCounter++);
				autoGeneratedName = 1;
			}

			// create a Tcl command to interface to cass
			ct->cmdToken = Tcl_CreateObjCommand (interp, commandName, casstcl_cassObjectObjCmd, ct, casstcl_cassObjectDelete);
			Tcl_SetObjResult (interp, Tcl_NewStringObj (commandName, -1));
			if (autoGeneratedName == 1) {
				ckfree(commandName);
			}
			break;
		}

		case OPT_LOGGING_CALLBACK: {
			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 1, objv, "option arg");
				return TCL_ERROR;
			}

			// if it already isn't null it was set to something, decrement
			// that object's reference count so it will probably be
			// deleted
			if (casstcl_loggingCallbackObj != NULL) {
				Tcl_DecrRefCount (casstcl_loggingCallbackObj);
				casstcl_loggingCallbackObj = NULL;
			}

			casstcl_loggingCallbackObj = objv[2];
			Tcl_IncrRefCount (casstcl_loggingCallbackObj);

			casstcl_loggingCallbackThreadId = Tcl_GetCurrentThread();

			cass_log_set_callback (casstcl_logging_callback, interp);
			break;
		}
		case OPT_LOG_LEVEL: {
			CassLogLevel cassLogLevel;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "level");
				return TCL_ERROR;
			}

			if (casstcl_obj_to_cass_log_level(interp, objv[2], &cassLogLevel) == TCL_OK) {
				cass_log_set_level(cassLogLevel);
			} else {
				return TCL_ERROR;
			}
			break;
		}
	}

    return TCL_OK;
}

/*
 *--------------------------------------------------------------
 *
 * casstcl_metrics -- obtain session metrics and return as a
 *   list of key-value pairs.
 *
 * Results:
 *      A list of metrics is returned.
 *
 * Side effects:
 *      None.
 *
 *--------------------------------------------------------------
 */
int casstcl_metrics (Tcl_Interp *interp, CassSession *session) {
	CassMetrics metrics;

#define MAX_SESSION_METRICS 42
	cass_session_get_metrics (session, &metrics);

	Tcl_Obj *listObjv[MAX_SESSION_METRICS];

	int i = 0;
	listObjv[i++] = Tcl_NewStringObj ("requests.min", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.requests.min);
	listObjv[i++] = Tcl_NewStringObj ("requests.max", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.requests.max);
	listObjv[i++] = Tcl_NewStringObj ("requests.mean", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.requests.mean);
	listObjv[i++] = Tcl_NewStringObj ("requests.stddev", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.requests.stddev);
	listObjv[i++] = Tcl_NewStringObj ("requests.median", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.requests.median);
	listObjv[i++] = Tcl_NewStringObj ("requests.percentile_75th", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.requests.percentile_75th);
	listObjv[i++] = Tcl_NewStringObj ("requests.percentile_95th", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.requests.percentile_95th);
	listObjv[i++] = Tcl_NewStringObj ("requests.percentile_98th", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.requests.percentile_98th);
	listObjv[i++] = Tcl_NewStringObj ("requests.percentile_99th", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.requests.percentile_99th);
	listObjv[i++] = Tcl_NewStringObj ("requests.percentile_999th", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.requests.percentile_999th);
	listObjv[i++] = Tcl_NewStringObj ("requests.mean_rate", -1);
	listObjv[i++] = Tcl_NewDoubleObj (metrics.requests.mean_rate);
	listObjv[i++] = Tcl_NewStringObj ("requests.one_minute_rate", -1);
	listObjv[i++] = Tcl_NewDoubleObj (metrics.requests.one_minute_rate);
	listObjv[i++] = Tcl_NewStringObj ("requests.five_minute_rate", -1);
	listObjv[i++] = Tcl_NewDoubleObj (metrics.requests.five_minute_rate);
	listObjv[i++] = Tcl_NewStringObj ("requests.fifteen_minute_rate", -1);
	listObjv[i++] = Tcl_NewDoubleObj (metrics.requests.fifteen_minute_rate);

	listObjv[i++] = Tcl_NewStringObj ("stats.total_connections", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.stats.total_connections);
	listObjv[i++] = Tcl_NewStringObj ("stats.available_connections", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.stats.available_connections);
	listObjv[i++] = Tcl_NewStringObj ("stats.exceeded_pending_requests_water_mark", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.stats.exceeded_pending_requests_water_mark);
	listObjv[i++] = Tcl_NewStringObj ("stats.exceeded_write_bytes_water_mark", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.stats.exceeded_write_bytes_water_mark);

	listObjv[i++] = Tcl_NewStringObj ("errors.connection_timeouts", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.errors.connection_timeouts);
	listObjv[i++] = Tcl_NewStringObj ("errors.pending_request_timeouts", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.errors.pending_request_timeouts);
	listObjv[i++] = Tcl_NewStringObj ("errors.request_timeouts", -1);
	listObjv[i++] = Tcl_NewWideIntObj (metrics.errors.request_timeouts);

	assert (i <= MAX_SESSION_METRICS);

	Tcl_SetObjResult (interp, Tcl_NewListObj (i, listObjv));
	return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * casstcl_select --
 *
 *      Given a cassandra query, array name and Tcl_Obj pointing to some
 *      Tcl code, perform the select, filling the named array with elements
 *      from each row in turn and executing code against it.
 *
 *      break, continue and return are supported (probably)
 *
 *      Issuing commands with async and processing the results with
 *      async foreach allows for greater concurrency.
 *
 * Results:
 *      A standard Tcl result.
 *
 *
 *----------------------------------------------------------------------
 */

int casstcl_select (casstcl_sessionClientData *ct, char *query, char *arrayName, Tcl_Obj *codeObj, int pagingSize, CassConsistency *consistencyPtr) {
	CassStatement* statement = NULL;
	int tclReturn = TCL_OK;
	Tcl_Interp *interp = ct->interp;

	statement = cass_statement_new(query, 0);

	cass_bool_t has_more_pages = cass_false;
	const CassResult* result = NULL;
	CassError rc = CASS_OK;
	int columnCount = -1;

	if (casstcl_setStatementConsistency(ct, statement, consistencyPtr) != TCL_OK) {
		return TCL_ERROR;
	}

	cass_statement_set_paging_size(statement, pagingSize);

	do {
		CassIterator* iterator;
		CassFuture* future = cass_session_execute(ct->session, statement);

		rc = cass_future_error_code(future);
		if (rc != CASS_OK) {
			tclReturn = casstcl_future_error_to_tcl (ct, rc, future);
			cass_future_free(future);
			break;
		}

		/*
		 * NOTE: *DEFENSIVE PROGRAMMING* This NULL check is probably
		 *       not absolutely required here; however, I discovered
		 *       that it is possible to have a successful future with
		 *       no result.
		 */
		result = cass_future_get_result(future);

		if (result == NULL) {
			Tcl_ResetResult (interp);
			Tcl_AppendResult (interp, "future has no result", NULL);
			tclReturn = TCL_ERROR;
			break;
		}

		iterator = cass_iterator_from_result(result);
		cass_future_free(future);

		if (columnCount == -1) {
			columnCount = cass_result_column_count (result);
		}

		while (cass_iterator_next(iterator)) {
			CassString cassNameString;
			int i;

			const CassRow* row = cass_iterator_get_row(iterator);

			// process all the columns into the tcl array
			for (i = 0; i < columnCount; i++) {
				Tcl_Obj *newObj = NULL;
				const char *columnName;
				const CassValue *columnValue;

				cass_result_column_name (result, i, &cassNameString.data, &cassNameString.length);
				columnName = cassNameString.data;

				columnValue = cass_row_get_column (row, i);

				if (cass_value_is_null (columnValue)) {
					Tcl_UnsetVar2 (interp, arrayName, columnName, 0);
					continue;
				}

				if (casstcl_cass_value_to_tcl_obj (ct, columnValue, &newObj) == TCL_ERROR) {
					tclReturn = TCL_ERROR;
					break;
				}

				if (newObj == NULL) {
					Tcl_UnsetVar2 (interp, arrayName, columnName, 0);
				} else {
					if (Tcl_SetVar2Ex (interp, arrayName, columnName, newObj, (TCL_LEAVE_ERR_MSG)) == NULL) {
						tclReturn = TCL_ERROR;
						break;
					}
				}
			}

			// now execute the code body
			int evalReturnCode = Tcl_EvalObjEx(interp, codeObj, 0);
			if ((evalReturnCode != TCL_OK) && (evalReturnCode != TCL_CONTINUE)) {
				// if it's TCL_BREAK we fall through to the break; tclReturn
				// is still TCL_OK so we don't have to change anything and
				// we don't want to propogate TCL_BREAK or TCL_CONTINE;
				// they are for us, not for our caller.  TCL_RETURN,
				// on the other hand, is return for our caller as well.
				//
				if (evalReturnCode == TCL_RETURN) {
					tclReturn = TCL_RETURN;
				} else if (evalReturnCode == TCL_ERROR) {
					char        msg[60];

					tclReturn = TCL_ERROR;

					sprintf(msg, "\n    (\"select\" body line %d)",
							Tcl_GetErrorLine(interp));
					Tcl_AddErrorInfo(interp, msg);
				}

				break;
			}
		}

		has_more_pages = cass_result_has_more_pages(result);

		if (has_more_pages) {
			cass_statement_set_paging_state(statement, result);
		}

		cass_iterator_free(iterator);
		cass_result_free(result);
	} while (has_more_pages && tclReturn == TCL_OK);

	cass_statement_free(statement);
	Tcl_UnsetVar (interp, arrayName, 0);

	return tclReturn;
}



/*
 *----------------------------------------------------------------------
 *
 * casstcl_cassObjectObjCmd --
 *
 *    dispatches the subcommands of a cass object command
 *
 * Results:
 *    stuff
 *
 *----------------------------------------------------------------------
 */
int
casstcl_cassObjectObjCmd(ClientData cData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
{
    int         optIndex;
	casstcl_sessionClientData *ct = (casstcl_sessionClientData *)cData;
	int resultCode = TCL_OK;

    static CONST char *options[] = {
        "async",
        "select",
        "exec",
        "connect",
		"prepare",
		"batch",
		"keyspaces",
		"tables",
		"columns",
		"columns_with_types",
		"reimport_column_type_map",
		"metrics",
        "cluster_version",
        "contact_points",
        "port",
        "protocol_version",
        "heartbeat_interval",
        "whitelist_filtering",
		"num_threads_io",
		"queue_size_io",
		"queue_size_event",
		"queue_size_log",
		"core_connections_per_host",
		"max_connections_per_host",
		"max_concurrent_creation",
		"max_concurrent_requests_threshold",
		"max_requests_per_flush",
		"write_bytes_high_water_mark",
		"write_bytes_low_water_mark",
		"pending_requests_high_water_mark",
		"pending_requests_low_water_mark",
		"connect_timeout",
		"request_timeout",
		"reconnect_wait_time",
		"credentials",
		"tcp_nodelay",
		"load_balance_round_robin",
		"load_balance_dc_aware",
		"token_aware_routing",
		"latency_aware_routing",
		"tcp_keepalive",
		"add_trusted_cert",
		"ssl_cert",
		"ssl_private_key",
		"ssl_verify_flag",
		"ssl_enable",
		"delete",
		"close",
        NULL
    };

    enum options {
        OPT_ASYNC,
        OPT_SELECT,
        OPT_EXEC,
        OPT_CONNECT,
		OPT_PREPARE,
		OPT_BATCH,
		OPT_LIST_KEYSPACES,
		OPT_LIST_TABLES,
		OPT_LIST_COLUMNS,
		OPT_LIST_COLUMN_TYPES,
		OPT_REIMPORT_COLUMN_TYPE_MAP,
		OPT_METRICS,
        OPT_CLUSTER_VERSION,
        OPT_CONTACT_POINTS,
        OPT_PORT,
        OPT_PROTOCOL_VERSION,
		OPT_HEARTBEAT_INTERVAL,
		OPT_WHITELIST_FILTERING,
		OPT_NUM_THREADS_IO,
		OPT_QUEUE_SIZE_IO,
		OPT_QUEUE_SIZE_EVENT,
		OPT_QUEUE_SIZE_LOG,
		OPT_CORE_CONNECTIONS_PER_HOST,
		OPT_MAX_CONNECTIONS_PER_HOST,
		OPT_MAX_CONCURRENT_CREATION,
		OPT_MAX_CONCURRENT_REQUESTS_THRESHOLD,
		OPT_MAX_REQUESTS_PER_FLUSH,
		OPT_WRITE_BYTES_HIGH_WATER_MARK,
		OPT_WRITE_BYTES_LOW_WATER_MARK,
		OPT_PENDING_REQUESTS_HIGH_WATER_MARK,
		OPT_PENDING_REQUESTS_LOW_WATER_MARK,
		OPT_CONNECT_TIMEOUT,
		OPT_REQUEST_TIMEOUT,
		OPT_RECONNECT_WAIT_TIME,
		OPT_CREDENTIALS,
		OPT_TCP_NODELAY,
		OPT_LOAD_BALANCE_ROUND_ROBIN,
		OPT_LOAD_BALANCE_DC_AWARE,
		OPT_TOKEN_AWARE_ROUTING,
		OPT_LATENCY_AWARE_ROUTING,
		OPT_TCP_KEEPALIVE,
		OPT_ADD_TRUSTED_CERT,
		OPT_SSL_CERT,
		OPT_SSL_PRIVATE_KEY,
		OPT_SSL_VERIFY_FLAG,
		OPT_SSL_ENABLE,
		OPT_DELETE,
		OPT_CLOSE
    };

    /* basic validation of command line arguments */
    if (objc < 2) {
        Tcl_WrongNumArgs (interp, 1, objv, "subcommand ?args?");
        return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj (interp, objv[1], options, "option", TCL_EXACT, &optIndex) != TCL_OK) {
		return TCL_ERROR;
    }

    switch ((enum options) optIndex) {
		case OPT_SELECT: {
			char *query;
			char *arrayName;
			char *consistencyName = NULL;
			Tcl_Obj *consistencyObj = NULL;
			CassConsistency consistency;
			Tcl_Obj *code;
			int pagingSize = 100;
			int arg = 2;
			int      subOptIndex;

			static CONST char *subOptions[] = {
				"-pagesize",
				"-consistency",
				NULL
			};

			enum subOptions {
				SUBOPT_PAGESIZE,
				SUBOPT_CONSISTENCY
			};

			// if we don't have at least five arguments and an odd number
			// of arguments at that, it's an error
			if ((objc < 5) || ((objc & 1) == 0)) {
				Tcl_WrongNumArgs (interp, 2, objv, "?-pagesize n? query arrayName code");
				return TCL_ERROR;
			}

			while (arg + 3 < objc) {
				if (Tcl_GetIndexFromObj (interp, objv[arg++], subOptions, "subOption", TCL_EXACT, &subOptIndex) != TCL_OK) {
					return TCL_ERROR;
				}

				switch ((enum subOptions) subOptIndex) {
					case SUBOPT_PAGESIZE: {
						if (Tcl_GetIntFromObj (interp, objv[arg++], &pagingSize) == TCL_ERROR) {
							Tcl_AppendResult (interp, " while converting paging size", NULL);
							return TCL_ERROR;
						}
						break;
					}
					case SUBOPT_CONSISTENCY: {
						consistencyObj = objv[arg++];
						consistencyName = Tcl_GetString(consistencyObj);
						if (strlen(consistencyName) > 0 && casstcl_obj_to_cass_consistency(ct, consistencyObj, &consistency) != TCL_OK) {
							return TCL_ERROR;
						}
						break;
					}
				}
			}

			query = Tcl_GetString (objv[arg++]);
			arrayName = Tcl_GetString (objv[arg++]);
			code = objv[arg++];

			return casstcl_select (ct, query, arrayName, code, pagingSize, (consistencyObj != NULL) ? &consistency : NULL);
		}

		case OPT_EXEC:
		case OPT_ASYNC: {
			CassStatement* statement = NULL;
			CassFuture *future = NULL;
			int arg = 2;
			int subOptIndex;
			Tcl_Obj *callbackObj = NULL;
			char *batchObjName = NULL;
			int futureFlags = 0;
			int upsert = 0;

			static CONST char *subOptions[] = {
				"-callback",
				"-batch",
				"-head",
				"-error_only",
				"-upsert",
				NULL
			};

			enum subOptions {
				SUBOPT_CALLBACK,
				SUBOPT_BATCH,
				SUBOPT_HEAD,
				SUBOPT_ERRORONLY,
				SUBOPT_UPSERT
			};

			// if we don't have at least three arguments, it's an error
			if (objc < 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "?-callback n? ?-batch batchObject? ?-head? ?-array arrayName? ?-table tableName? ?-prepared preparedName? ?-consistency level? statement ?args? OR ?-upsert ?-mapunkown columnname? ?-nocomplain? ?-ifnotexists? table args?");
				return TCL_ERROR;
			}

			while (arg + 1 < objc) {
				// stop as soon as you don't match something, leaving arg
				// at the not-matched thing (i.e. don't use arg++ in
				// this statement)
				if (Tcl_GetIndexFromObj (NULL, objv[arg], subOptions, "subOption", TCL_EXACT, &subOptIndex) != TCL_OK) {
					break;
				}
				arg++;

				switch ((enum subOptions) subOptIndex) {
					case SUBOPT_CALLBACK: {
						callbackObj = objv[arg++];
						break;
					}

					case SUBOPT_BATCH: {
						batchObjName = Tcl_GetString (objv[arg++]);
						break;
					}

					case SUBOPT_HEAD: {
						futureFlags |= (CASSTCL_FUTURE_QUEUE_HEAD_FLAG);
						break;
					}
					
					case SUBOPT_ERRORONLY: {
					    futureFlags |= (CASSTCL_FUTURE_CALLBACK_ON_ERROR_ONLY);
						break;	
					}
					
					case SUBOPT_UPSERT: {
						upsert = 1;
						break;
					}
					
				}
			}

			if (batchObjName != NULL) {
				if (arg != objc) {
					Tcl_ResetResult (interp);
					Tcl_AppendResult (interp, "batch usage: obj ?-callback callback? ?-head? -batch batchName", NULL);
					return TCL_ERROR;
				}

				// get the batch object from the command name we extracted
				casstcl_batchClientData *bcd = casstcl_batch_command_to_batchClientData (interp, batchObjName);
				if (bcd == NULL) {
					Tcl_ResetResult (interp);
					Tcl_AppendResult (interp, "batch object '", batchObjName, "' doesn't exist or isn't a batch object", NULL);
					return TCL_ERROR;
				}
				const CassBatch *batch = bcd->batch;

				future = cass_session_execute_batch (ct->session, batch);

			} else if (upsert) {
				int newObjc = objc - arg;
				Tcl_Obj *CONST *newObjv = objv + arg;

				if (casstcl_make_upsert_statement_from_objv (ct, newObjc, newObjv, NULL, &statement) == TCL_ERROR) {
					return TCL_ERROR;
	
				}
				
				future = cass_session_execute (ct->session, statement);
				cass_statement_free (statement);

			} else {
				// it's a statement, possibly with arguments

				if (casstcl_make_statement_from_objv (ct, objc, objv, arg, &statement) == TCL_ERROR) {
					return TCL_ERROR;
				}

				future = cass_session_execute (ct->session, statement);
				cass_statement_free (statement);
			}

			// even with exec if you use -callback it's asynchronous
			if (((enum options) optIndex == OPT_EXEC) && (callbackObj == NULL)) {
				// synchronous
				cass_future_wait (future);

				CassError rc = cass_future_error_code (future);
				if (rc != CASS_OK) {
					resultCode = casstcl_future_error_to_tcl (ct, rc, future);
				}

				cass_future_free (future);
			} else {
				// asynchronous
				if (casstcl_createFutureObjectCommand (ct, future, callbackObj, futureFlags) == TCL_ERROR) {
					resultCode = TCL_ERROR;
				}
			}

			break;
		}

		case OPT_CONNECT: {
			CassError rc = CASS_OK;
			CassFuture *future;
			char *keyspace = NULL;
			int arg = 2;
			int      subOptIndex;
			Tcl_Obj *callbackObj = NULL;

			static CONST char *subOptions[] = {
				"-callback",
				NULL
			};

			enum subOptions {
				SUBOPT_CALLBACK
			};

			if (objc < 2) {
				Tcl_WrongNumArgs (interp, 2, objv, "?keyspace?");
				return TCL_ERROR;
			}

			while (arg + 1 < objc) {
				// stop as soon as you don't match something, leaving arg
				// at the not-matched thing (i.e. don't use arg++ in
				// this statement)
				if (Tcl_GetIndexFromObj (NULL, objv[arg], subOptions, "subOption", TCL_EXACT, &subOptIndex) != TCL_OK) {
					break;
				}
				arg++;

				switch ((enum subOptions) subOptIndex) {
					case SUBOPT_CALLBACK: {
						callbackObj = objv[arg++];
						break;
					}
				}
			}

			if (arg >= objc) {
				future = cass_session_connect (ct->session, ct->cluster);
			} else {
				keyspace = Tcl_GetString (objv[arg]);
				future = cass_session_connect_keyspace (ct->session, ct->cluster, keyspace);
			}

			if (callbackObj != NULL) {
				// asynchronous
				if (casstcl_createFutureObjectCommand (ct, future, callbackObj, 0) == TCL_ERROR) {
					resultCode = TCL_ERROR;
				}
			} else {
				cass_future_wait (future);

				rc = cass_future_error_code (future);
				if (rc == CASS_OK) {
					// import the schema keyspaces, tables, columns and types
					casstcl_reimport_column_type_map (ct);
				} else {
					resultCode = casstcl_future_error_to_tcl (ct, rc, future);
				}

				cass_future_free (future);
			}
			break;
		}

		case OPT_PREPARE: {
			char *query = NULL;
			CassError rc = CASS_OK;
			CassFuture *future;
			char *statementString;
			int statementStringLength;

			if (objc != 5) {
				Tcl_WrongNumArgs (interp, 2, objv, "name table statement");
				return TCL_ERROR;
			}

			statementString = Tcl_GetStringFromObj (objv[4], &statementStringLength);

			future = cass_session_prepare (ct->session, statementString);

			cass_future_wait (future);

			rc = cass_future_error_code (future);
			if (rc != CASS_OK) {
				resultCode = casstcl_future_error_to_tcl (ct, rc, future);
				cass_future_free (future);
				Tcl_AppendResult (interp, " while attempting to prepare statement '", query, "'", NULL);
				break;
			}

			const CassPrepared *cassPrepared = cass_future_get_prepared (future);
			cass_future_free (future);

			// allocate one of our cass prepared data objects for Tcl
			// and configure it
			casstcl_preparedClientData *pcd = (casstcl_preparedClientData *)ckalloc (sizeof (casstcl_preparedClientData));

			pcd->cass_prepared_magic = CASS_PREPARED_MAGIC;
			pcd->ct = ct;
			pcd->prepared = cassPrepared;

			pcd->string = ckalloc (statementStringLength + 1);
			strncpy (pcd->string, statementString, statementStringLength);

			pcd->tableNameObj = objv[3];
			Tcl_IncrRefCount (pcd->tableNameObj);


			char *commandName = Tcl_GetString (objv[2]);

#define PREPARED_STRING_FORMAT "prepared%lu"
			// if commandName is #auto, generate a unique name for the object
			int autoGeneratedName = 0;
			if (strcmp (commandName, "#auto") == 0) {
				static unsigned long nextAutoCounter = 0;
				int baseNameLength = snprintf (NULL, 0, PREPARED_STRING_FORMAT, nextAutoCounter) + 1;
				commandName = ckalloc (baseNameLength);
				snprintf (commandName, baseNameLength, PREPARED_STRING_FORMAT, nextAutoCounter++);
				autoGeneratedName = 1;
			}

			// create a Tcl command to interface to cass
			pcd->cmdToken = Tcl_CreateObjCommand (interp, commandName, casstcl_preparedObjectObjCmd, pcd, casstcl_preparedObjectDelete);
			Tcl_SetObjResult (interp, Tcl_NewStringObj (commandName, -1));
			if (autoGeneratedName == 1) {
				ckfree(commandName);
			}
			break;
		}

		case OPT_BATCH: {
			CassBatchType cassBatchType = CASS_BATCH_TYPE_LOGGED;

			if (objc < 3 || objc > 4) {
				Tcl_WrongNumArgs (interp, 1, objv, "name ?type?");
				return TCL_ERROR;
			}

			if (objc == 4) {
				if (casstcl_obj_to_cass_batch_type (interp, objv[3], &cassBatchType) == TCL_ERROR) {
					Tcl_AppendResult (interp, " while determining batch type", NULL);
					return TCL_ERROR;
				}
			}

			return casstcl_createBatchObjectCommand (ct, Tcl_GetString (objv[2]), cassBatchType);
		}

		case OPT_LIST_KEYSPACES: {
			Tcl_Obj *obj = NULL;
			if (objc != 2) {
				Tcl_WrongNumArgs (interp, 2, objv, "");
				return TCL_ERROR;
			}

			resultCode = casstcl_list_keyspaces (ct, &obj);
			if (obj != NULL) {
				Tcl_SetObjResult (ct->interp, obj);
			}
			break;
		}

		case OPT_LIST_TABLES: {
			Tcl_Obj *obj = NULL;
			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "keyspace");
				return TCL_ERROR;
			}

			char *keyspace = Tcl_GetString (objv[2]);

			resultCode = casstcl_list_tables (ct, keyspace, &obj);
			if (obj != NULL) {
				Tcl_SetObjResult (ct->interp, obj);
			}
			break;
		}

		case OPT_LIST_COLUMNS:
		case OPT_LIST_COLUMN_TYPES: {
			Tcl_Obj *obj = NULL;
			if (objc != 4) {
				Tcl_WrongNumArgs (interp, 2, objv, "keyspace tableName");
				return TCL_ERROR;
			}

			char *keyspace = Tcl_GetString (objv[2]);
			char *table = Tcl_GetString (objv[3]);

			resultCode = casstcl_list_columns (ct, keyspace, table, (optIndex == OPT_LIST_COLUMN_TYPES), &obj);
			if (obj != NULL) {
				Tcl_SetObjResult (ct->interp, obj);
			}
			break;
		}

		case OPT_REIMPORT_COLUMN_TYPE_MAP: {
			if (objc != 2) {
				Tcl_WrongNumArgs (interp, 2, objv, "");
				return TCL_ERROR;
			}

			resultCode = casstcl_reimport_column_type_map (ct);
			break;
		}

		case OPT_METRICS: {
			if (objc != 2) {
				Tcl_WrongNumArgs (interp, 2, objv, "");
				return TCL_ERROR;
			}

			resultCode = casstcl_metrics (interp, ct->session);
			break;
		}

		case OPT_CLUSTER_VERSION: {
		#if CASS_VERSION_MAJOR > 2 || \
			(CASS_VERSION_MAJOR == 2 && (CASS_VERSION_MINOR > 3 || \
			(CASS_VERSION_MINOR == 3 && \
			CASS_VERSION_PATCH >= 0)))
			CassVersion version;
			const CassSchemaMeta *schema_meta;
			Tcl_Obj *pResultStr = NULL;
		#endif

			if (objc != 2) {
				Tcl_WrongNumArgs (interp, 2, objv, "");
				return TCL_ERROR;
			}

		#if CASS_VERSION_MAJOR > 2 || \
			(CASS_VERSION_MAJOR == 2 && (CASS_VERSION_MINOR > 3 || \
			(CASS_VERSION_MINOR == 3 && \
			CASS_VERSION_PATCH >= 0)))
			// Getting the connected cluster's Cassandra version
			// CPP Driver for Cassandra required >= v2.3.0
			schema_meta = cass_session_get_schema_meta (ct->session);
			version = cass_schema_meta_version(schema_meta);

			pResultStr = Tcl_NewListObj(0, NULL);
			Tcl_ListObjAppendElement(interp, pResultStr, Tcl_NewIntObj(version.major_version));
			Tcl_ListObjAppendElement(interp, pResultStr, Tcl_NewIntObj(version.minor_version));
			Tcl_ListObjAppendElement(interp, pResultStr, Tcl_NewIntObj(version.patch_version));

			cass_schema_meta_free (schema_meta);

			Tcl_SetObjResult(interp, pResultStr);
		#else
			Tcl_SetObjResult(interp, Tcl_NewStringObj("This version does not support", -1));
			return TCL_ERROR;
		#endif
			break;
		}

		case OPT_CONTACT_POINTS: {
			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "address_list");
				return TCL_ERROR;
			}

			cass_cluster_set_contact_points(ct->cluster, Tcl_GetString(objv[2]));
			break;
		}

		case OPT_PORT: {
			int port = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "port");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &port) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting port element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_port(ct->cluster, port);
			break;
		}

		case OPT_PROTOCOL_VERSION: {
			int protocolVersion = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "protocolVersion");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &protocolVersion) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting protocolVersion element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_protocol_version(ct->cluster, protocolVersion);
			break;
		}

		case OPT_HEARTBEAT_INTERVAL: {
			int heartbeatInterval = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "heartbeatInterval");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &heartbeatInterval) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting heartbeatInterval element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_connection_idle_timeout (ct->cluster, heartbeatInterval);
			break;
		}

		case OPT_WHITELIST_FILTERING: {
			if (objc > 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "?hostList?");
				return TCL_ERROR;
			}

			if (objc == 2) {
				cass_cluster_set_whitelist_filtering (ct->cluster, "");
				break;
			}

			cass_cluster_set_whitelist_filtering (ct->cluster, Tcl_GetString (objv[2]));
			break;
		}


		case OPT_NUM_THREADS_IO: {
			int numThreadsIO = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "numThreadsIO");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &numThreadsIO) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting numThreadsIO element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_num_threads_io(ct->cluster, numThreadsIO);
			break;
		}

		case OPT_QUEUE_SIZE_IO: {
			int queueSizeIO = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "queueSizeIO");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &queueSizeIO) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting queueSizeIO element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_queue_size_io(ct->cluster, queueSizeIO);
			break;
		}

		case OPT_QUEUE_SIZE_EVENT: {
			int queueSizeEvent = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "queueSizeEvent");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &queueSizeEvent) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting queueSizeEvent element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_queue_size_event(ct->cluster, queueSizeEvent);
			break;
		}

		case OPT_QUEUE_SIZE_LOG: {
			int queueSizeLog = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "queueSizeLog");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &queueSizeLog) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting queueSizeLog element", NULL);
				return TCL_ERROR;
			}

#if 0
			cass_cluster_set_queue_size_log (ct->cluster, queueSizeLog);
#endif
			break;
		}

		case OPT_CORE_CONNECTIONS_PER_HOST: {
			int coreConnectionsPerHost = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "coreConnectionsPerHost");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &coreConnectionsPerHost) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting coreConnectionsPerHost element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_core_connections_per_host (ct->cluster, coreConnectionsPerHost);
			break;
		}

		case OPT_MAX_CONNECTIONS_PER_HOST: {
			int maxConnectionsPerHost = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "maxConnectionsPerHost");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &maxConnectionsPerHost) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting maxConnectionsPerHost element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_max_connections_per_host (ct->cluster, maxConnectionsPerHost);
			break;
		}

		case OPT_MAX_CONCURRENT_CREATION: {
			int maxConcurrentCreation = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "maxConcurrentCreation");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &maxConcurrentCreation) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting maxConcurrentCreation element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_max_concurrent_creation (ct->cluster, maxConcurrentCreation);
			break;
		}

		case OPT_MAX_CONCURRENT_REQUESTS_THRESHOLD: {
			int maxConcurrentRequestsThreshold = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "maxConcurrentRequestsThreshold");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &maxConcurrentRequestsThreshold) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting maxConcurrentRequestsThreshold element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_max_concurrent_requests_threshold (ct->cluster, maxConcurrentRequestsThreshold);
			break;
		}

		case OPT_MAX_REQUESTS_PER_FLUSH: {
			int maxRequestsPerFlush = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "maxRequestsPerFlush");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &maxRequestsPerFlush) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting maxRequestsPerFlush element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_max_requests_per_flush (ct->cluster, maxRequestsPerFlush);
			break;
		}

		case OPT_WRITE_BYTES_HIGH_WATER_MARK: {
			int writeBytesHighWaterMark = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "writeBytesHighWaterMark");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &writeBytesHighWaterMark) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting writeBytesHighWaterMark element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_write_bytes_high_water_mark (ct->cluster, writeBytesHighWaterMark);
			break;
		}

		case OPT_WRITE_BYTES_LOW_WATER_MARK: {
			int writeBytesLowWaterMark = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "writeBytesLowWaterMark");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &writeBytesLowWaterMark) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting writeBytesLowWaterMark element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_write_bytes_low_water_mark (ct->cluster, writeBytesLowWaterMark);
			break;
		}

		case OPT_PENDING_REQUESTS_HIGH_WATER_MARK: {
			int pendingRequestsHighWaterMark = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "pendingRequestsHighWaterMark");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &pendingRequestsHighWaterMark) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting pendingRequestsHighWaterMark element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_pending_requests_high_water_mark (ct->cluster, pendingRequestsHighWaterMark);
			break;
		}

		case OPT_PENDING_REQUESTS_LOW_WATER_MARK: {
			int pendingRequestsLowWaterMark = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "pendingRequestsLowWaterMark");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &pendingRequestsLowWaterMark) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting pendingRequestsLowWaterMark element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_pending_requests_low_water_mark (ct->cluster, pendingRequestsLowWaterMark);
			break;
		}

		case OPT_CONNECT_TIMEOUT: {
			int timeoutMS = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "ms");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &timeoutMS) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting timeoutMS element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_connect_timeout(ct->cluster, timeoutMS);
			break;
		}

		case OPT_REQUEST_TIMEOUT: {
			int timeoutMS = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "ms");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &timeoutMS) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting timeoutMS element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_request_timeout(ct->cluster, timeoutMS);
			break;
		}

		case OPT_RECONNECT_WAIT_TIME: {
			int waitMS = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "ms");
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[2], &waitMS) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting waitMS element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_reconnect_wait_time (ct->cluster, waitMS);
			break;
		}

		case OPT_TCP_NODELAY: {
			int enable = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "enableFlag");
				return TCL_ERROR;
			}

			if (Tcl_GetBooleanFromObj (interp, objv[2], &enable) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting enable element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_tcp_nodelay(ct->cluster, enable);
			break;
		}

		case OPT_LOAD_BALANCE_ROUND_ROBIN: {
			if (objc != 2) {
				Tcl_WrongNumArgs (interp, 2, objv, "");
				return TCL_ERROR;
			}

			cass_cluster_set_load_balance_round_robin (ct->cluster);
			break;
		}

		case OPT_LOAD_BALANCE_DC_AWARE: {
			char *localDC;
			int usedHostsPerRemoteDC;
			cass_bool_t allowRemoteDCS;
			int allowFlag;

			if (objc != 5) {
				Tcl_WrongNumArgs (interp, 2, objv, "local_dc hosts_per_remote_dc allow_remote_dcs");
				return TCL_ERROR;
			}

			localDC = Tcl_GetString (objv[3]);

			if (Tcl_GetIntFromObj (interp, objv[4], &usedHostsPerRemoteDC) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting usedHostsPerRemoteDC element", NULL);
				return TCL_ERROR;
			}

			if (Tcl_GetBooleanFromObj (interp, objv[5], &allowFlag) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting allowRemoteDCS element", NULL);
				return TCL_ERROR;
			}
			allowRemoteDCS = (allowFlag) ? cass_true : cass_false;

			CassError cassError = cass_cluster_set_load_balance_dc_aware (ct->cluster, localDC, usedHostsPerRemoteDC, allowRemoteDCS);
			if (cassError != CASS_OK) {
				return casstcl_cass_error_to_tcl (ct, cassError);
			}
			break;
		}


		case OPT_TOKEN_AWARE_ROUTING: {
			int enable = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "enableFlag");
				return TCL_ERROR;
			}

			if (Tcl_GetBooleanFromObj (interp, objv[2], &enable) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting enable element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_token_aware_routing(ct->cluster, enable);
			break;
		}

		case OPT_LATENCY_AWARE_ROUTING: {
			int enable = 0;

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "enableFlag");
				return TCL_ERROR;
			}

			if (Tcl_GetBooleanFromObj (interp, objv[2], &enable) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting enable element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_latency_aware_routing(ct->cluster, enable);
			break;
		}

		case OPT_TCP_KEEPALIVE: {
			int enable = 0;
			int delaySecs = 0;

			if (objc != 4) {
				Tcl_WrongNumArgs (interp, 2, objv, "enableFlag delaySecs");
				return TCL_ERROR;
			}

			if (Tcl_GetBooleanFromObj (interp, objv[2], &enable) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting enable element", NULL);
				return TCL_ERROR;
			}

			if (Tcl_GetIntFromObj (interp, objv[3], &delaySecs) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while converting delaySecs element", NULL);
				return TCL_ERROR;
			}

			cass_cluster_set_tcp_keepalive (ct->cluster, enable, delaySecs);
			break;
		}


		case OPT_CREDENTIALS: {
			char *username = NULL;
			char *password = NULL;

			if (objc != 4) {
				Tcl_WrongNumArgs (interp, 2, objv, "username password");
				return TCL_ERROR;
			}

			username = Tcl_GetString (objv[2]);
			password = Tcl_GetString (objv[3]);

			cass_cluster_set_credentials (ct->cluster, username, password);
			break;
		}

		case OPT_ADD_TRUSTED_CERT: {
			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "pemFormattedCertString");
				return TCL_ERROR;
			}

			cass_ssl_add_trusted_cert (ct->ssl, Tcl_GetString (objv[2]));
			break;
		}

		case OPT_SSL_CERT: {
			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "pemFormattedCertString");
				return TCL_ERROR;
			}

			cass_ssl_set_cert (ct->ssl, Tcl_GetString (objv[2]));
			break;
		}

		case OPT_SSL_PRIVATE_KEY: {
			if (objc != 4) {
				Tcl_WrongNumArgs (interp, 2, objv, "pemFormattedCertString password");
				return TCL_ERROR;
			}

			cass_ssl_set_private_key (ct->ssl, Tcl_GetString (objv[2]), Tcl_GetString (objv[3]));
			break;
		}

		case OPT_SSL_VERIFY_FLAG: {
			int         subOptIndex;
			int flags = 0;

			static CONST char *subOptions[] = {
				"none",
				"verify_peer_certificate",
				"verify_peer_identity",
				NULL
			};

			enum subOptions {
				SUBOPT_NONE,
				SUBOPT_VERIFY_PEER_CERT,
				SUBOPT_VERIFY_PEER_IDENTITY
			};

			if (objc != 3) {
				Tcl_WrongNumArgs (interp, 2, objv, "flag");
				return TCL_ERROR;
			}

			if (Tcl_GetIndexFromObj (interp, objv[2], subOptions, "subOption", TCL_EXACT, &subOptIndex) != TCL_OK) {
				return TCL_ERROR;
			}

			switch ((enum subOptions) subOptIndex) {
				case SUBOPT_NONE: {
					flags = CASS_SSL_VERIFY_NONE;
					break;
				}

				case SUBOPT_VERIFY_PEER_CERT: {
					flags = CASS_SSL_VERIFY_PEER_CERT;
					break;
				}

				case SUBOPT_VERIFY_PEER_IDENTITY: {
					flags = CASS_SSL_VERIFY_PEER_IDENTITY;
					break;
				}
			}

			cass_ssl_set_verify_flags (ct->ssl, flags);
			break;
		}

		case OPT_SSL_ENABLE: {
			if (objc != 2) {
				Tcl_WrongNumArgs (interp, 2, objv, "");
				return TCL_ERROR;
			}

			cass_cluster_set_ssl (ct->cluster, ct->ssl);
			break;
		}

		case OPT_DELETE: {
			if (objc != 2) {
				Tcl_WrongNumArgs (interp, 2, objv, "");
				return TCL_ERROR;
			}

			cass_session_close (ct->session);
			Tcl_DeleteCommandFromToken (ct->interp, ct->cmdToken);
			break;
		}

		case OPT_CLOSE: {
			if (objc != 2) {
				Tcl_WrongNumArgs (interp, 2, objv, "");
				return TCL_ERROR;
			}

			cass_session_close (ct->session);
			break;
		}
	}

    return resultCode;
}

/*
 *----------------------------------------------------------------------
 *
 * casstcl_make_upsert_statement_from_objv --
 *
 *   This takes an objv and objc containing possible arguments such
 *   as -mapunknown, -nocomplain and -ifnotexists and in the objv
 *   always a fully qualified table name and a list of key-value pairs
 *
 *   It creates a cass statement and if successful sets the caller's
 *   pointer to a pointer to a cass statement to that statement
 *
 *   It returns a standard Tcl result, TCL_ERROR if something went
 *   wrong and you don't get a statement
 *
 *   It returns TCL_OK if all went well
 *
 *   This uses casstcl_make_upsert_statement to make the statement after
 *   it figures the arguments thereto
 *
 * Results:
 *      A standard Tcl result.
 *
 *----------------------------------------------------------------------
 */
int
casstcl_make_upsert_statement_from_objv (casstcl_sessionClientData *ct, int objc, Tcl_Obj *CONST objv[], CassConsistency *consistencyPtr, CassStatement **statementPtr)
{
	Tcl_Interp *interp = ct->interp;
	int ifNotExists = 0;
	int dropUnknown = 0;
	char *mapUnknown = NULL;
	int arg = 0;

    int         optIndex;
    static CONST char *options[] = {
        "-mapunknown",
        "-nocomplain",
        "-ifnotexists",
        NULL
    };

    enum options {
        OPT_MAPUNKNOWN,
        OPT_NOCOMPLAIN,
        OPT_IFNOTEXISTS,
    };

    /* basic validation of command line arguments */
    if (objc < 2) {
        Tcl_WrongNumArgs (interp, 0, objv, "?-mapunknown columnName? ?-nocomplain? ?-ifnotexists? keyspace.tableName keyValuePairList");
        return TCL_ERROR;
    }

	for (arg = 0; arg < objc - 2; arg++) {
		if (Tcl_GetIndexFromObj (interp, objv[arg], options, "option", TCL_EXACT, &optIndex) != TCL_OK) {
			return TCL_ERROR;
		}

		switch ((enum options) optIndex) {
			case OPT_MAPUNKNOWN: {
				if (arg + 1 >= objc - 2) {
					Tcl_ResetResult (interp);
					Tcl_AppendResult (interp, "-mapunknown requires a column name", NULL);
					return TCL_ERROR;
				}

				mapUnknown = Tcl_GetString (objv[++arg]);
				break;
			}

			case OPT_NOCOMPLAIN: {
				dropUnknown = 1;
				break;
			}

			case OPT_IFNOTEXISTS: {
				ifNotExists = 1;
				break;
			}
		}
	}

	char *tableName = Tcl_GetString (objv[objc - 2]);

	return casstcl_make_upsert_statement (ct, tableName, objv[objc - 1], consistencyPtr, statementPtr, mapUnknown, dropUnknown, ifNotExists);
}

/*
 *----------------------------------------------------------------------
 *
 * casstcl_list_keyspaces --
 *
 *      Return a list of the extant keyspaces in the cluster by
 *      examining the metadata managed by the driver.
 *
 *      The cpp-driver docs indicate that the driver stays abreast with
 *      changes to the schema so we prefer to ask it rather than
 *      caching our own copy, or something.
 *
 * Results:
 *      A standard Tcl result.
 *
 *----------------------------------------------------------------------
 */
int
casstcl_list_keyspaces (casstcl_sessionClientData *ct, Tcl_Obj **objPtr) {
	const CassSchemaMeta *schemaMeta = cass_session_get_schema_meta (ct->session);
	CassIterator *iterator = cass_iterator_keyspaces_from_schema_meta (schemaMeta);
	Tcl_Obj *listObj = Tcl_NewObj();
	int tclReturn = TCL_OK;

	while (cass_iterator_next(iterator)) {
		const char *keyspaceName;
		size_t keyspaceNameLength;

		const CassKeyspaceMeta *keyspaceMeta = cass_iterator_get_keyspace_meta (iterator);

		cass_keyspace_meta_name (keyspaceMeta, &keyspaceName, &keyspaceNameLength);

		if (Tcl_ListObjAppendElement (ct->interp, listObj, Tcl_NewStringObj (keyspaceName, keyspaceNameLength)) == TCL_ERROR) {
			tclReturn = TCL_ERROR;
			break;
		}
	}

	cass_iterator_free (iterator);
	cass_schema_meta_free (schemaMeta);
	*objPtr = listObj;
	return tclReturn;
}

/*
 *----------------------------------------------------------------------
 *
 * casstcl_list_tables --
 *
 *      Set the Tcl result to a list of the extant tables in a keyspace by
 *      examining the metadata managed by the driver.
 *
 *      This is cool because the driver will update the metadata if the
 *      schema changes during the session and further examinations of the
 *      metadata by the casstcl metadata-accessing functions will see the
 *      changes
 *
 * Results:
 *      A standard Tcl result.
 *
 *----------------------------------------------------------------------
 */
int
casstcl_list_tables (casstcl_sessionClientData *ct, char *keyspace, Tcl_Obj **objPtr) {
	const CassSchemaMeta *schemaMeta = cass_session_get_schema_meta (ct->session);
	const CassKeyspaceMeta *keyspaceMeta = cass_schema_meta_keyspace_by_name (schemaMeta, keyspace);
	Tcl_Interp *interp = ct->interp;

	if (keyspaceMeta == NULL) {
		Tcl_ResetResult (interp);
		Tcl_AppendResult (interp, "keyspace '", keyspace, "' not found", NULL);
		return TCL_ERROR;
	}

	CassIterator *iterator = cass_iterator_tables_from_keyspace_meta (keyspaceMeta);
	Tcl_Obj *listObj = Tcl_NewObj();
	int tclReturn = TCL_OK;

	while (cass_iterator_next(iterator)) {
		const char *tableName;
		size_t tableNameLength;

		const CassTableMeta *tableMeta = cass_iterator_get_table_meta (iterator);

		cass_table_meta_name (tableMeta, &tableName, &tableNameLength);

		if (Tcl_ListObjAppendElement (interp, listObj, Tcl_NewStringObj (tableName, tableNameLength)) == TCL_ERROR) {
			tclReturn = TCL_ERROR;
			break;
		}
	}
	cass_iterator_free (iterator);
	cass_schema_meta_free (schemaMeta);
	*objPtr = listObj;
	return tclReturn;
}

/*
 *----------------------------------------------------------------------
 *
 * casstcl_list_columns --
 *
 *      Set a Tcl object pointer to a list of the extant columns in the
 *      specified table in the specified keyspace by examining the
 *      metadata managed by the driver.
 *
 *      If includeTypes is 1 then instead of listing just the columns it
 *      also lists their data types, as a list of key-value pairs.
 *
 * Results:
 *      A standard Tcl result.
 *
 *----------------------------------------------------------------------
 */
int
casstcl_list_columns (casstcl_sessionClientData *ct, char *keyspace, char *table, int includeTypes, Tcl_Obj **objPtr) {
	const CassSchemaMeta *schemaMeta = cass_session_get_schema_meta (ct->session);
	Tcl_Interp *interp = ct->interp;

	// locate the keyspace
	const CassKeyspaceMeta *keyspaceMeta = cass_schema_meta_keyspace_by_name (schemaMeta, keyspace);

	if (keyspaceMeta == NULL) {
		Tcl_ResetResult (interp);
		Tcl_AppendResult (interp, "keyspace '", keyspace, "' not found", NULL);
		return TCL_ERROR;
	}

	// locate the table within the keyspace
	const CassTableMeta *tableMeta = cass_keyspace_meta_table_by_name (keyspaceMeta, table);

	if (tableMeta == NULL) {
		Tcl_ResetResult (interp);
		Tcl_AppendResult (interp, "table '", table, "' not found in keyspace '", keyspace, "'", NULL);
		return TCL_ERROR;
	}

	// prepare to iterate on the columns within the table
	CassIterator *iterator = cass_iterator_columns_from_table_meta (tableMeta);
	Tcl_Obj *listObj = Tcl_NewObj();
	int tclReturn = TCL_OK;

	// iterate on the columns within the table
	while (cass_iterator_next(iterator)) {
		const char *columnName;
		size_t columnNameLength;

		const CassColumnMeta *columnMeta = cass_iterator_get_column_meta (iterator);

		// get the field name and append it to the list we are creating
		cass_column_meta_name (columnMeta, &columnName, &columnNameLength);

		if (Tcl_ListObjAppendElement (interp, listObj, Tcl_NewStringObj (columnName, columnNameLength)) == TCL_ERROR) {
			tclReturn = TCL_ERROR;
			break;
		}
		// if including types then get the data type and append it to the
		// list too
		if (includeTypes) {
			const CassDataType *columnDataType = cass_column_meta_data_type (columnMeta);
			CassValueType valueType = cass_data_type_type (columnDataType);
			const char *typeName = casstcl_cass_value_type_to_string (valueType);

			if (Tcl_ListObjAppendElement (interp, listObj, Tcl_NewStringObj (typeName, -1)) == TCL_ERROR) {
				tclReturn = TCL_ERROR;
				break;
			}
		}
	}
	cass_iterator_free (iterator);
	cass_schema_meta_free (schemaMeta);
	*objPtr = listObj;

	if (tclReturn == TCL_OK) {
		Tcl_ResetResult (interp);
	}

	return tclReturn;
}


/*
 *----------------------------------------------------------------------
 *
 * casstcl_make_upsert_statement --
 *
 *   given a session client data, fully qualified table name, Tcl list
 *   obj and a pointer to a statement pointer,
 *
 *   this baby...
 *
 *     ...generates an upsert statement (in the form of insert but that's
 *     how cassandra rolls)
 *
 *     ...uses casstcl_bind_names_from_list to bind the data elements
 *     to the statement using the right data types
 *
 *   It creates a cassandra statement and sets your pointer to it
 *
 * Results:
 *      A standard Tcl result.
 *
 *----------------------------------------------------------------------
 */
int
casstcl_make_upsert_statement (casstcl_sessionClientData *ct, char *tableName, Tcl_Obj *listObj, CassConsistency *consistencyPtr, CassStatement **statementPtr, char *mapUnknown, int dropUnknown, int ifNotExists) {
	int listObjc;
	Tcl_Obj **listObjv;
	Tcl_Interp *interp = ct->interp;
	int tclReturn = TCL_OK;

	if (Tcl_ListObjGetElements (interp, listObj, &listObjc, &listObjv) == TCL_ERROR) {
		Tcl_AppendResult (interp, " while parsing list of key-value pairs", NULL);
		return TCL_ERROR;
	}

	if (listObjc & 1) {
		Tcl_ResetResult (interp);
		Tcl_AppendResult (interp, "key-value pair list must contain an even number of elements", NULL);
		return TCL_ERROR;
	}

	Tcl_DString ds;
	Tcl_DStringInit (&ds);
	Tcl_DStringAppend (&ds, "INSERT INTO ", -1);
	Tcl_DStringAppend (&ds, tableName, -1);
	Tcl_DStringAppend (&ds, " (", 2);

	int i;
	int nFields = 0;
	int didOne = 0;
	int nUnknownToMap = 0;

	casstcl_cassTypeInfo *typeInfo = (casstcl_cassTypeInfo *)ckalloc (sizeof (casstcl_cassTypeInfo) * (listObjc / 2));

	for (i = 0; i < listObjc; i += 2) {
		int varNameLength;

		tclReturn = casstcl_typename_obj_to_cass_value_types (interp, tableName, listObjv[i], &typeInfo[i/2]);

// printf("casstcl_make_upsert_statement figured out i %d table '%s' from '%s' type info %d, %d, %d\n", i, tableName, Tcl_GetString (listObjv[i]), typeInfo[i/2].cassValueType, typeInfo[i/2].valueSubType1, typeInfo[i/2].valueSubType2);

		if (tclReturn == TCL_ERROR) {
			break;
		}

		// failed to find it?
		if (tclReturn == TCL_CONTINUE) {
			if (dropUnknown) {
				tclReturn = TCL_OK;
				continue;
			}

			// if moving of unrecognized colum-value pairs to a map collection
			// is enabled, skip this column for now but keep count of how
			// many columns we are mapping

			if (mapUnknown != NULL) {
				nUnknownToMap++;
				tclReturn = TCL_OK;
				continue;
			}

			// ok, we weren't told to drop unknown columns and we weren't
			// told to map them, so we've found one and it's an error
			Tcl_ResetResult (interp);
			Tcl_AppendResult (interp, "unknown column '", Tcl_GetString(listObjv[i]), "' in upsert for table '", tableName, "'", NULL);
			tclReturn = TCL_ERROR;
			break;
		}

		char *varName = Tcl_GetStringFromObj (listObjv[i], &varNameLength);

		// prepend a comma unless it's the first one
		if (didOne) {
			Tcl_DStringAppend (&ds, ",", 1);
		}

		Tcl_DStringAppend (&ds, varName, varNameLength);
		nFields++;
		didOne = 1;
	}

	// if we were told to map unknown and we found something unknown,
	// append the name of the map column to the insert
	if (nUnknownToMap > 0) {
		if (didOne) {
			Tcl_DStringAppend (&ds, ",", 1);
		}
		Tcl_DStringAppend (&ds, mapUnknown, -1);
		nFields++;
	}

	// now generate the values part of the insert
	Tcl_DStringAppend (&ds, ") values (", -1);

	for (i = 0; i < nFields; i++) {
		if (i > 0) {
			Tcl_DStringAppend (&ds, ",?", 2);
		} else {
			Tcl_DStringAppend (&ds, "?", 1);
		}
	}

	if (ifNotExists) {
		Tcl_DStringAppend (&ds, ") IF NOT EXISTS", -1);
	} else {
		Tcl_DStringAppend (&ds, ")", -1);
	}

	// if we're good to here, bind the variables corresponding to the insert
	if (tclReturn == TCL_OK) {

		char *query = Tcl_DStringValue (&ds);
// printf("nFields %d, upsert query is '%s'\n", nFields, query);
		CassStatement *statement = cass_statement_new (query, nFields);
		int bindField = 0;

		tclReturn = casstcl_setStatementConsistency(ct, statement, consistencyPtr);

		if (tclReturn != TCL_OK) {
			goto cleanup;
		}

		for (i = 0; i < listObjc; i += 2) {
// printf("casstcl_make_upsert_statement i %d type info %d, %d, %d\n", i, typeInfo[i/2].cassValueType, typeInfo[i/2].valueSubType1, typeInfo[i/2].valueSubType2);
			// skip value if type lookup previously determined unknown
			if (typeInfo[i/2].cassValueType == CASS_VALUE_TYPE_UNKNOWN) {
// printf("skip unknown field '%s', value '%s'\n", Tcl_GetString (listObjv[i]), Tcl_GetString(listObjv[i+1]));
				continue;
			}

			// get the value out of the list
			Tcl_Obj *valueObj = listObjv[i+1];

			assert (bindField < nFields);

// printf("bind field %d, name '%s', value '%s'\n", bindField, Tcl_GetString (listObjv[i]), Tcl_GetString(valueObj));
			tclReturn = casstcl_bind_tcl_obj (ct, statement, NULL, 0, bindField++, &typeInfo[i/2], valueObj);
			if (tclReturn == TCL_ERROR) {
				Tcl_AppendResult (interp, " while constructing upsert statement, while attempting to bind field '", Tcl_GetString (listObjv[i]), "' of type '", casstcl_cass_value_type_to_string (typeInfo[i/2].cassValueType), "', value '", Tcl_GetString (valueObj), "' referencing table '", tableName, "'", NULL);
				break;
			}
		}

		// if mapping of unknown column-value pairs is enabled and there are
		// some, map them now
		if (nUnknownToMap > 0) {
			CassCollection *collection = cass_collection_new (CASS_COLLECTION_TYPE_MAP, nUnknownToMap);

			for (i = 0; i < listObjc; i += 2) {
				// consult our cache of the types,
				// skip value if type lookup previously determined known
				if (typeInfo[i/2].cassValueType != CASS_VALUE_TYPE_UNKNOWN) {
					continue;
				}

				// ok, got one, append the column name to the map
				CassError cassError = casstcl_append_tcl_obj_to_collection (ct, collection, CASS_VALUE_TYPE_TEXT, listObjv[i]);
				// i don't think these can really fail, a text conversion
				if (cassError != CASS_OK) {
					tclReturn = casstcl_cass_error_to_tcl (ct, cassError);
					break;
				}

				// now append the column value to the map
				cassError = casstcl_append_tcl_obj_to_collection (ct, collection, CASS_VALUE_TYPE_TEXT, listObjv[i+1]);
				if (cassError != CASS_OK) {
					tclReturn = casstcl_cass_error_to_tcl (ct, cassError);
					break;
				}
			}
			// bind the map collection of key-value pairs to the statement
			assert (bindField < nFields);
// printf("bound collection position %d nFields %d\n", bindField, nFields);
			CassError cassError = cass_statement_bind_collection (statement, bindField, collection);
			cass_collection_free (collection);
			if (cassError != CASS_OK) {
				tclReturn = casstcl_cass_error_to_tcl (ct, cassError);
			}
		}

		// if everything's OK, set the caller's statement pointer to the
		// statement we made
		if (tclReturn == TCL_OK) {
			*statementPtr = statement;
		}
	}

cleanup:

	// free the insert statement
	Tcl_DStringFree (&ds);

	// free the type info cache
	ckfree((char *) typeInfo);

	return tclReturn;
}

/*
 *----------------------------------------------------------------------
 *
 * casstcl_make_statement_from_objv --
 *
 *   This is a beautiful thing because it will work from the like four
 *   places where we generate statements: exec, select, async, and
 *   batch.
 *
 *   This is like what would be in the option-handling case statements.
 *
 *   We will look at the objc and objv we are given with what's in front
 *   of the command that got invoked stripped off, that is for example
 *   if the command was
 *
 *       $batch add -array row $query column column column
 *
 *       $batch add $query $value $type $value $type
 *
 *   ...we expect to get it from "-array" on, that is, they'll pass us
 *   the address of the objv starting from there and the objc properly
 *   discounting whatever preceded the stuff we handle
 *
 *   We then figure it out and invoke the underlying stuff.
 *
 * Results:
 *      A standard Tcl result.
 *
 *----------------------------------------------------------------------
 */
int
casstcl_make_statement_from_objv (casstcl_sessionClientData *ct, int objc, Tcl_Obj *CONST objv[], int argOffset, CassStatement **statementPtr) {
	int arrayStyle = 0;
	char *arrayName = NULL;
	char *tableName = NULL;
	char *preparedName = NULL;
	char *consistencyName = NULL;
	Tcl_Obj *consistencyObj = NULL;
	CassConsistency consistency;
	Tcl_Interp *interp = ct->interp;

    static CONST char *options[] = {
        "-array",
		"-table",
		"-prepared",
		"-consistency",
        NULL
    };

    enum options {
        OPT_ARRAY,
		OPT_TABLE,
		OPT_PREPARED,
		OPT_CONSISTENCY
	};

	int newObjc = objc - argOffset;
	Tcl_Obj *CONST *newObjv = objv + argOffset;
	int optIndex;
	int arg = 0;

	while (arg < newObjc) {
		char *optionString = Tcl_GetString (newObjv[arg]);

		// if the first character isn't a dash, we're done here.
		// this is going to get called a lot so i don't want
		// Tcl_GetIndexFromObj writing an error message and all
		// that stuff unless there really is an option
		if (*optionString != '-') {
			break;
		}

		// OK so we aren't going to accept anything starting with - that
		// isn't in our option list
		if (Tcl_GetIndexFromObj (interp, newObjv[arg++], options, "option",
			TCL_EXACT, &optIndex) != TCL_OK) {
			return TCL_ERROR;
		}

		switch ((enum options) optIndex) {
			case OPT_ARRAY: {
				if (arg >= newObjc) {
					goto wrong_numargs;
				}

				arrayName = Tcl_GetString (newObjv[arg++]);
				arrayStyle = 1;
				break;
			}

			case OPT_TABLE: {
				if (arg >= newObjc) {
					goto wrong_numargs;
				}

				tableName = Tcl_GetString (newObjv[arg++]);
				arrayStyle = 1;
				break;
			}

			case OPT_PREPARED: {
				if (arg >= newObjc) {
					goto wrong_numargs;
				}

				preparedName = Tcl_GetString (newObjv[arg++]);
// printf("saw prepared case, name = '%s'\n", preparedName);
				break;
			}

			case OPT_CONSISTENCY: {
				if (arg >= newObjc) {
					goto wrong_numargs;
				}

				consistencyObj = newObjv[arg++];
				consistencyName = Tcl_GetString(consistencyObj);
// printf("saw consistency case, name = '%s'\n", consistencyName);

				if (strlen(consistencyName) > 0 && casstcl_obj_to_cass_consistency(ct, consistencyObj, &consistency) != TCL_OK) {
					return TCL_ERROR;
				}
				break;
			}
		}
	}

//printf ("looking for query, arg %d, newObjc %d\n", arg, newObjc);

	// There are several different possibilities here in terms of the list
	// of arguments (i.e. the ones already processed and those that remain
	// to be processed):
	//
	//     1. There are no arguments left.  This is fine if the query is
	//        prepared (i.e. the -prepared option was processed).  This
	//        means there are *NO* name/value pairs to bind.
	//
	//     2. There is exactly one argument left.  This is always fine.
	//
	//     3. There is more than one argument left.  This is fine if the
	//        -prepared option was not processed; otherwise, this is an
	//        error.
	//
	// This check is used to determine if we ran out of arguments without
	// having processed the -prepared option.
	//
	if (arg >= newObjc && preparedName == NULL) {
	  wrong_numargs:
		Tcl_WrongNumArgs (interp, (argOffset <= 2) ? argOffset : 2, objv, "?-array arrayName? ?-table tableName? ?-prepared preparedName? ?-consistency level? ?query? ?arg...?");
		return TCL_ERROR;
	}

	if (preparedName != NULL && arrayStyle) {
		Tcl_ResetResult (interp);
		Tcl_AppendResult (interp, "-prepared cannot be used with -table / -array", NULL);
		return TCL_ERROR;
	}

	// if prepared, handle it
	if (preparedName != NULL) {
// printf("prepared case branch, name = '%s'\n", preparedName);

		// locate the prepared statement structure we created earlier
		casstcl_preparedClientData * pcd = casstcl_prepared_command_to_preparedClientData (interp, preparedName);
		int listObjc = 0;
		Tcl_Obj **listObjv = NULL;

		if (pcd == NULL) {
			Tcl_ResetResult (interp);
			Tcl_AppendResult (interp, "-prepared argument '", preparedName, "' isn't a valid prepared statement object", NULL);
			return TCL_ERROR;
		}

		// there must be exactly one argument left.  the list of
		// name/value pairs, which must contain an even number of
		// elements.
		if (arg < newObjc && arg + 1 != newObjc) {
			Tcl_WrongNumArgs (interp, (argOffset <= 2) ? argOffset : 2, objv, "-prepared prepared ?list?");
			return TCL_ERROR;
		}

		if (arg < newObjc) {
			// split out the column_name-value pairs of names and values
			if (Tcl_ListObjGetElements (interp, newObjv[arg++], &listObjc, &listObjv) == TCL_ERROR) {
				Tcl_AppendResult (interp, " while parsing list of column-value pairs", NULL);
				return TCL_ERROR;
			}

			if (listObjc & 1) {
				Tcl_ResetResult (interp);
				Tcl_AppendResult (interp, "list must contain an even number of elements", NULL);
				return TCL_ERROR;
			}
		}
		return casstcl_bind_names_from_prepared (pcd, listObjc, listObjv, (consistencyObj != NULL) ? &consistency : NULL, statementPtr);
	}

	char *query = Tcl_GetString (newObjv[arg++]);
	// (whatever is left of the newObjv from arg to the end are column-related)

	if (arrayStyle) {
		if (tableName == NULL) {
			Tcl_ResetResult (interp);
			Tcl_AppendResult (interp, "-table must be specified if -array is specified", NULL);
			return TCL_ERROR;
		}

		if (arrayName == NULL) {
			Tcl_ResetResult (interp);
			Tcl_AppendResult (interp, "-array must be specified if -table is specified", NULL);
			return TCL_ERROR;
		}

		return casstcl_bind_names_from_array (ct, tableName, query, arrayName, newObjc - arg, &newObjv[arg], (consistencyObj != NULL) ? &consistency : NULL, statementPtr);
	} else {
		return casstcl_bind_values_and_types (ct, query, newObjc - arg, &newObjv[arg], (consistencyObj != NULL) ? &consistency : NULL, statementPtr);
	}
}



/*
 *----------------------------------------------------------------------
 *
 * casstcl_reimport_column_type_map --
 *    Call out to the Tcl interpreter to invoke
 *    ::casstcl::import_column_type_map from the casstcl library;
 *    the proc resides in source file is casstcl.tcl.
 *
 *    This convenience function gets called from a method of the
 *    casstcl cass object and is invoked upon connection as well
 *
 * Results:
 *    The program compiles.
 *
 *----------------------------------------------------------------------
 */
int
casstcl_reimport_column_type_map (casstcl_sessionClientData *ct)
{
	int tclReturnCode;
	Tcl_Interp *interp = ct->interp;
	Tcl_Obj *evalObjv[2];

	// construct an objv we'll pass to eval.
	// first is the command
	// second is the name of cassandra connection object
	evalObjv[0] = Tcl_NewStringObj ("::casstcl::import_column_type_map", -1);
	evalObjv[1] = Tcl_NewObj();
	Tcl_GetCommandFullName(interp, ct->cmdToken, evalObjv[1]);

	// eval the command.  this should traverse the metadata and extract
	// the types of all the columns of all the tables of all the keyspaces

	Tcl_IncrRefCount (evalObjv[0]);
	Tcl_IncrRefCount (evalObjv[1]);

	tclReturnCode = Tcl_EvalObjv (interp, 2, evalObjv, (TCL_EVAL_GLOBAL|TCL_EVAL_DIRECT));

	Tcl_DecrRefCount(evalObjv[0]);
	Tcl_DecrRefCount(evalObjv[1]);

	return tclReturnCode;
}



#if 0
/*
 *----------------------------------------------------------------------
 *
 * casstcl_DumpAddrInfo --
 *
 *	Attempts to dump the contents of the struct addrinfo.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void casstcl_DumpAddrInfo(
  FILE *pFile,
  struct addrinfo *pAddrInfo,
  int indent
){
  int index;
  uint8_t *pAddress = NULL  if( !pAddrInfo ) return;
  if( indent>0 ) fprintf(pFile, "\n");
  fprintf(pFile, "%*s", indent * 2, "");
  fprintf(pFile, "pAddrInfo = [%p\n", pAddrInfo);
  fprintf(pFile, "%*s", indent * 2, "");
  fprintf(pFile, "  ->flags = %d\n", pAddrInfo->ai_flags);
  fprintf(pFile, "%*s", indent * 2, "");
  fprintf(pFile, "  ->family = %d\n", pAddrInfo->ai_family);
  fprintf(pFile, "%*s", indent * 2, "");
  fprintf(pFile, "  ->socktype = %d\n", pAddrInfo->ai_socktype);
  fprintf(pFile, "%*s", indent * 2, "");
  fprintf(pFile, "  ->protocol = %d\n", pAddrInfo->ai_protocol);
  fprintf(pFile, "%*s", indent * 2, "");
  fprintf(pFile, "  ->addrlen = %d\n", (int)pAddrInfo->ai_addrlen);
  fprintf(pFile, "%*s", indent * 2, "");
  fprintf(pFile, "  ->addr = [");
  if(pAddrInfo->ai_family == AF_INET){
    struct sockaddr_in *pSockAddr = (struct sockaddr_in *)pAddrInfo->ai_addr;
    pAddress = (uint8_t *)&pSockAddr->sin_addr.s_addr;
    fprintf(pFile, "IPv4 [");
  }else if(pAddrInfo->ai_family == AF_INET6){
    struct sockaddr_in6 *pSockAddr = (struct sockaddr_in6 *)pAddrInfo->ai_addr;
    pAddress = (uint8_t *)&pSockAddr->sin6_addr.s6_addr;
    fprintf(pFile, "IPv6 [");
  }else{
    fprintf(pFile, "<not_ipv4_or_ipv6>");
  }
  if( pAddress ){
    for (index=0; index<pAddrInfo->ai_addrlen; index++) {
      if( index>0 ){
        fprintf(pFile, ", ");
      }
      fprintf(pFile, "%d", (int)(pAddress[index]));
    }
  }
  fprintf(pFile, "]]\n");
  fprintf(pFile, "%*s", indent * 2, "");
  fprintf(pFile, "  ->canonname = \"%s\"\n", pAddrInfo->ai_canonname);
  fprintf(pFile, "%*s", indent * 2, "");
  fprintf(pFile, "  ->next = [%p]\n", pAddrInfo->ai_next);
  casstcl_DumpAddrInfo(pFile, pAddrInfo->ai_next, indent + 1);
  fprintf(pFile, "%*s", indent * 2, "");
  fprintf(pFile, "]\n");
}
#endif

/* vim: set ts=4 sw=4 sts=4 noet : */

